### Переменные и константы
Имена переменных в выражении, т.е. когда требуется значение переменной, а не ее имя, всегда начинаются с символа '$'. Например: $a, $n, $opyat_povislo и т.п. Длина имени переменной ограничена 254 символами.

Переменные всегда считаются глобальными на уровне данной системы, за исключением тех случаев, когда они передаются в качестве параметров события.

Тип переменной объявляется с помощью оператора declare (<имя переменной> declare <тип переменной>). Переменные могут быть типа число (integer), строка (string), буфер (buffer) и очередь (queue). Изменять тип переменной нельзя.

Значения типа число могут рассматриваться в качестве логических значений (0 - ложь, любое другое значение - истина) в выражениях, включающих логические операции и в операторе условного перехода.

Строковые константы записываются в двойных кавычках. 

Символьные константы можно записывать через их числовой код с помощью символа “#”. Например, символ “1” можно записать следующими способами: “1” или #49.

Числовые константы записываются традиционным образом, как в языках Pascal, C и т.д.

Константы типа буфер или очередь в языке не определены.

### Операции над строками
      +     производит сцепление (конкатенацию) строк 
      pos(<строковое выражение>,<переменная-строка>) 

      Пример:
 
            pos(“bc”, s)      если $s="abcd", то результат 2, 

                              если $s="abdс", то результат 0

Функция pos ищет вхождение подстроки в строке и возвращает номер первого символа подстроки в строке или 0, если строка не содержит подстроки или в случае какой-либо ошибки. Например, если переменная имеет тип integer или вместо строкового выражения написано числовое выражение.

            copy (<исходная строка>,<начало>,<длина>)

      Пример:

            copy (s, 2, 3) если $s="abcdef", то результат "bcd"

Функция copy возвращает подстроку указанной длины, начинающуюся с указанной позиции в строке. 

Со строками возможны операции сравнения. Операции равенства и неравенства сравнивают содержимое строк, остальные сравнивают длину строк.

### Другие операции
                Над переменными любого типа определена функция sizeof.

      Синтаксис:

            sizeof(<имя переменной>)

      Пример:

            sizeof(me)

      Функция sizeof возвращает размер переданной ей переменной в байтах. Для переменных типа буфер функция sizeof возвращает размер буфера, для переменных типа строка возвращает длину строки, для переменных типа число возвращает 1.

                Функция random.

      Синтаксис:

            random(<выражение>)

      Пример:

            random(1000)

      Функция random возвращает случайное неотрицательное число меньшее <выражение>. 

      Функция SystemTime() возвращает текущее системное время.

      Функция CurrentSystemName() возвращает имя системы в которой произошло событие.

### Метки
      Любая строка программы может быть предварена меткой, заканчивающейся двоеточием. Например:
      cool_label: N_DISCONNECT.REQ eventdown address $a
### Комментарии
      Строка, начинающаяся с символа ';', считается комментарием и игнорируется при исполнении программы.

### Оператор присваивания (varset)
Синтаксис:
<выражение> varset <имя переменной>
      Пример:

$other_cool_variable+1 varset my_cool_variable
      Оператор вычисляет значение указываемого выражения и присваивает переменной с заданным именем. Если переменная уже была создана и ее тип не совпадает с типом вычисленного выражения, возникает ошибка времени выполнения.

### Операторы управления примитивами (generateup, eventdown, timer, untimer)
      Синтаксис:
           <имя_примитива> generateup { <имя_параметра> <выражение> }

            <имя_примитива> eventdown { <имя_параметра> <выражение> }

            <имя события> timer <имя переменной> <задержка> { <имя_параметра> <выражение> }

            untimer <выражение>
      Пример:

           S_DISCONNECT.IND generateup address $a

            N_DISCONNECT.REQ eventdown address $a

            T_CONNECT_TIMEOUT timer timer1 400+$lastctime nextctime $lastctime+100 userdata $udata

            untimer $timer1

      Операторы generateup и eventdown производят локализированную пересылку примитива с данного уровня через соответствующие точки доступа объектам соответственно выше- и нижележащего уровней (генерируют примитив на уровне выше текущего и ниже текущего соответственно с заданным именем и списком параметров).

      Оператор timer генерирует событие на текущем уровне через указанный интервал времени в системных единицах времени начиная с момента обработки данного оператора с заданными именем события и списком параметров. В переменную с указанным именем помещается числовой идентификатор таймера, который затем может быть использован в качестве выражения, передаваемого оператору untimer. Если в текущей момент имеется запущенный таймер, идентификатор которого равен значению переменной в момент вызова оператора, то значение переменной не изменяется, и данный идентификатор соответствует нескольким таймерам. Если запущенных таймеров с таким идентификатором нет, то значение переменной изменится на новое. В указанном примере оператор timer вызовет генерацию события T_CONNECT_TIMEOUT с параметрами nextctime  и userdata равными соответственно $lastctime+100 и $udata через 400+$lastctime системных единиц времени.

      Оператор untimer отменяет генерацию отложенного события с указанным числовым идентификатором. Если имеется несколько отложенных событий с одинаковым идентификатором, то все они будут отменены.

### Операторы управления буферами (bufferit, unbufferit, calccrc)
 
      Синтаксис:
            <имя переменной-буфера> bufferit <длина буфера> { <значение поля в буфере> <длина поля> }
            unbufferit <имя переменной-буфера> { <имя переменной> <длина поля> }
            calccrc < имя переменной-числа > < имя переменной-буфера >
      Пример:
            ctrlbuf bufferit 1025 $userdata 1024 $dcrc 1
            unbufferit ctrlbuf userdata 1024 dcrc 1
            calccrc paccrc $databuffer

      Оператор bufferit создает переменную типа буфер из полей указанной длины. Если фактическая длина переданного значения оказывается меньше указанной длины поля, то остаток отведенного поля заполняется нулями. Если суммарная длина полей оказывается больше размера буфера, то происходит ошибка времени выполнения.

      Оператор unbufferit разбивает переменную типа буфер на поля указанной длины. Если при этом из буфера необходимо извлечь строковую переменную, то ее тип должен быть установлен до выполнения оператора unbufferit.

      Оператор calccrc подсчитывает контрольную сумму буфера и заносит ее в переменную с заданным именем. Если тип переменной не совпадает с типом число, возникает ошибка времени выполнения.

### Операторы управления очередями (queue, clearqueue, dequeue, qcount, peek)
      Синтаксис:
            queue <имя очереди> <выражение>

            clearqueue <имя очереди>

            dequeue (<имя очереди>)

            peek (<имя очереди>)

            qcount (<имя очереди>)

      Примеры:
            queue my_queue $fully_useless_data
            clearqueue my_queue
            dequeue (my_queue)
            peek (my_queue)
            qcount (my_queue)

      Оператор queue добавляет элемент в очередь с указанным именем. Элемент может иметь любой тип; при извлечении элемента из очереди выражение будет иметь тот же тип, что и добавленный элемент (т.е. тип выражения будет  сохранен в очереди). Одна и та же очередь может содержать элементы различных типов.

      Оператор clearqueue удаляет все элементы из очереди с указанным именем.

      Над очередями определены функции dequeue, peek и qcount. Функция dequeue возвращает первый элемент очереди с указанным именем; если очередь пуста, возникает ошибка времени выполения. Функция peek возвращает первый элемент очереди с указанным именем не удаляя его из очереди; если очередь пуста, возникает ошибка времени выполения.Операция qcount возвращает число элементов, находящихся в очереди.

      Возможно копировать одну очередь в другую с помощью оператора присваивания.

### Операторы управления (goto, if, return, subprog, substart, subend)
      Синтаксис:
            goto <имя метки>

            <выражение> if <имя метки>

            subprog <имя подпрограммы>

            substart <имя подпрограммы>

            subend 

            return 

      Пример:
            goto podozhdem_esche_naverno
            $chislo_paketov > 100 if disconnect_ego
            subprog my_super_sub
            substart my_super_sub
            subend 
            return 

      Оператор goto вызывает безусловный переход на заданную метку.

      Оператор if вызывает переход на заданную метку в случае, если  переданное выражение является логически истинным (т.е. является выражением типа число, отличным от нуля). В противном случае выполнение программы продолжается.

      Оператор subprog вызывает переход на подпрограмму. Максимальная вложенность вызовов 20.

      Оператор substart обозначает начало подпрограммы. В случае попадания на оператор без вызова подпрограммы возникает ошибка. Перед блоком с подпрограммами используйте оператор return. 

      Оператор subend обозначает конец подпрограммы. Подпрограммы объявляются локально - то есть существуют только в рамках примитива, в котором определены.

      Оператор return завершает обработку события

### Операторы диагностики (out, outon, outoff)

      Синтаксис:
            out <выражение>
      Пример:
            out ($chislo_oblomov_na_linii+$chislo_moih_oshibok)/2
      Оператор out выводит значение вычисленного выражения (строкового или числового) в диагностическое окно. Если вычисленное выражение имеет тип буфер, то в окне выводится размер этого буфера. Операторы outon и outoff включают и выключают вывод соответсвенно.

### Операторы управления строками (delete)
      Синтаксис:
            delete <строка> <начало> <длина>
      Пример:
            delete s 2 3 если $s="abcdef", то $s="aef"
Оператор delete удаляет из строки подстроку указанной длины, начинаются с указанной позиции в строке.

### Ограничения, накладываемые языком
Очереди не являются переменными и с ними невозможны никакие операции, кроме queue и dequeue (и declare).

Невозможна передача управления посредством goto на метку, находящуюся в описании другого примитива (метки и подпрограммы всегда локальны).

Невозможно создание локальных переменных иным способом, кроме как путем передачи их в виде параметров, соответствующих событию. Кроме того, параметры, соответствующие событию, всегда доступны только для чтения (т.е. попытка выполнения присваивания в коде обработчика события переменной, имя которой совпадает с именем параметра, вызовет ошибку времени выполнения).



